---
title: "Leading Indicators DAP"
author: "Kate Harwood, Vishnu Shankar, Ben Smith, Sangwon Hyun"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 7, fig.height=7, echo=TRUE, warning=FALSE,
                      message=FALSE, eval=FALSE, cache=FALSE)
source("LeadingIndicatorTools.R")
library(covidcast)
library(magrittr)
library(tidyverse)
library(assertthat)
library(lubridate)
library(gridExtra)
library(dplyr)
library(cowplot)
library(ggpubr)
library(patchwork)
library(ggpubr)
```

## Motivation
TODO Vishnu's section? Justin is happy to help here.


## Data

TODO Explain data in 1-2 paragraphs here.

TODO Also include some introductory plots. Preferably ones from a single county
that we can continue to refer to later on, like county 01003

## Methodology

#### Initial exploration: Cross Correlation

Our first approach to this DAP looked at the relationship between the indicator
and the signal more generally. We first used cross-correlation to identify the
relationship between indicators and cases across a time period. For two time
series $y, x \in \mathbb{R}^T$, cross-correlation is defined as:

$$\max_{i} Corr(y_{i+1,\cdots, T}, x_{1, \cdots, T-i}),$$

and measures the maximum Pearson correlation between the two as a result of
lagging one by the amount of $i$.

We calculated the cross-correlation and the optimal lag in each county. An
example of this data over all observed counties for the Drs Visits indicator
signal:


```{r}
doit <- function(){
  ## Produce cross-correlation analysis.

  ## Make plots of the distribution of max-cross-correlations, and also

  ## Show how much the (max) cross-correlation increases when we isolate to the
  ## time regions near peaks?

  ## https://delphi-org.slack.com/files/U0170DWHNRW/F01F9S62WGK/vshankar_fb_community_signals_leading_indicator_11_20_20.pdf

  ## Any other useful analysis that proves "leadingness" from this stage of
  ## analysis?

}
```

This exploratory analysis hints at a predictive relationship; that indicators,
observed in advance, can have high correlation with case counts. However,
cross-correlation measures a more general relationship between the time series,
since high cross-correlation can occur due to flat regions of the time series,
or even decreasing regions.

The main analysis in the project aims for a more specific question of whether
sharp upswings in cases -- something significant within a county, and of
particular public health importance, as well as of practical importance for
modeling and forecasting. We want to analyze the whether a *significant
indicator rise* precedes *significant case rise*.

#### Identifying Rises in Signals

In order to ascertain leading-ness of an indicator, we want to determining
whether the indicator began to rise significantly before cases began to rise
significantly.

As a core component of this analysis, we need methodology to accurately identify
significant rises, given a single time series of indicator. This is non-trivial,
since the data is quite noisy at the county level, and clean rise/drops are
rare.

[TODO: Plot an example of a county where the times series are quite noisy]

Our main method is to deem a time period as a significant rise if:

1. Estimate the smoothed curve of the time series, using smoothing splines with
   (). Note, this smoothing is in addition to the 7-day average smoothing
   already applied to the data (e.g. 7-day average CLI)
2. Estimate a local derivative of the two curves.
3. Deem a time period significant rise point as:
 - First derivative at each point is > 0.
     - This means: *signal is in fact rising on every day*.
 - Period is longer a certain number of days (for this analysis we used 5)
     - This means: *it's not just a spurious rise*.
 - Each first derivative is > a certain % of other derivatives in time period
    (for this analysis we used 75%)
     - This means: *the rise is a significant one for this county. This ties
       this decision to the specific time period we are looking at, and the rise
       point identifications can change based on the time period because of this
       criteria.*
  - Magnitude of increase from start to end of period is larger than a certain
    threshold (for this analysis we used 20%)
     - This means: *another way to make sure that the rise is significant, not
       just a slight uptick in cases*
 

Additionally, we take the point at the beginning of each rise period as the best
estimation of a point of *inflection* where a signal *begins* to rise
significantly, so we can address a specific question:

**Does the beginning of a rise in the indicator come before the beginning of a
rise in cases?**

While this is admittedly a very specific question to ask about leading-ness, it
is valuable because we can frame it as a classification problem, into which we
can introduce baseline predictors, and compare specific performance measures
such as recall and precision.

We can also ask the slightly more general questions:

**Does the beginning of a rise in the indicator come before the rise in cases?**

Also, the flip question is:

**How often does the cases remain flat even after the beginning of a rise in the
indicator?**


<br>
<br>


#### Recall and Precision using classification framework

TODO: fill in the methodology for the per-time-point and per-county analysis here.


#### More general Recall and Precision

TODO: fill in the methodology for Vishnu's more general R/P analysis.


<br>


## Walkthrough of pipeline

In this section, we describe our pipeline for processing, plotting and analyzing
the data using the methodology described above.

We examine this in two ways for specific time periods during the pandemic, like
the "Summer wave" or the "Fall wave." We only include counties that have greater
than 2000 cases (a little over 20 cases a day for a 3 month window), 80 days of
indicator data for a 3 month window, and do not have zero or negative values for
ither cases or the indicator.


##### Step 1. Get and prepare county data

As an example, we'll use our Dr Visits % CLI as our indicator, and the summer as
our time period. We use our LeadingIndicatorTools package for all our main
functions.

```{r, results='hide'}
drs_visits_prepared_summer = get_and_parse_signals("2020-06-01", "2020-8-31", "doctor-visits", "smoothed_adj_cli", 2000, 80)
```
<br>

#### Step 2. We can plot the Drs Visits and the case signal together for an example county.
```{r, results='hide'}
drs_summer = get_increase_points(drs_visits_prepared_summer$cases, drs_visits_prepared_summer$indicator)
```

```{r}
plot_signals(drs_summer, "01003", smooth_and_show_increase_point=FALSE, "Drs Visits")
```
<br>

#### Step 3. Mark the rise points (the points at the beginning of the rise periods) for the Drs Visits and Cases signal. 

In the respective rise point columns, the day is marked with a 1 if it is found
to be a rise point for that signal. We can see here that there is a rise point
for Drs Vists on 6/18 and for cases on 6/26.

```{r}
drs_summer[1]
```
<br>

#### Step 4. Plot the smoothed signal with the beginning rise points. 

We can see that Drs Visits begins to rise before cases rise. TODO I think we
need to tweak our rise point method a bit so we don't have these "double
counting" points on a rise.

```{r}
plot_signals(drs_summer, "01003", smooth_and_show_increase_point=TRUE, "Drs Visits")
```

## Analysis Results {.tabset .tabset-fade .tabset-pills}

### Doctor Visits
```{r, results='hide'}
drs_visits_prepared_fall = get_and_parse_signals("2020-09-01", "2020-11-30", "doctor-visits", "smoothed_adj_cli", 2000, 80)
drs_visits_prepared_summer = get_and_parse_signals("2020-06-01", "2020-8-31", "doctor-visits", "smoothed_adj_cli", 2000, 80)
```
```{r, results='hide'}
drs_fall = get_increase_points(drs_visits_prepared_fall$cases, drs_visits_prepared_fall$indicator)
drs_summer = get_increase_points(drs_visits_prepared_summer$cases, drs_visits_prepared_summer$indicator)

success_examples_drs_fall = get_success_examples(drs_fall, success_window_max = 14, success_window_min = 3)
success_examples_drs_summer = get_success_examples(drs_summer, success_window_max = 14, success_window_min = 3)
```

#### We can plot some of the counties where rises in the doctor visits indicator consistently lead rises in cases. {.tabset .tabset-fade .tabset-pills}

##### Examples from the Summer
```{r, echo=FALSE}
plot_example_list(success_examples_drs_summer, drs_summer, "Doctor Visits CLI")
```

##### Examples from the Fall
```{r, echo=FALSE}
plot_example_list(success_examples_drs_fall, drs_fall, "Doctor Visits CLI")
```

##### Examples of counties that show successes in both Summer and Fall
```{r, echo=FALSE}
plot_example_intersects(success_examples_drs_summer, success_examples_drs_fall, drs_summer, drs_fall, "Doctor Visits CLI")
```
##### Fall Frequencies
We can also look at the distribution of the frequency of the number of days by which Doctor Visits' rises lead case rises in successful counties
```{r echo=FALSE}
plot_distribution_freq(success_examples_drs_fall, drs_fall)
```

##### Summer Frequencies
We can also look at the distribution of the frequency of the number of days by which Doctor Visits' rises lead case rises in successful counties
```{r echo=FALSE}
plot_distribution_freq(success_examples_drs_summer, drs_summer)
```


### Change Healthcare
```{r, results='hide', echo=FALSE}
change_healthcare_prepared_fall = get_and_parse_signals("2020-09-01", "2020-11-30", "chng", "smoothed_adj_outpatient_cli", 2000, 80)
change_healthcare_prepared_summer = get_and_parse_signals("2020-06-01", "2020-08-31", "chng", "smoothed_adj_outpatient_cli", 2000, 80)
```
```{r results="hide", echo=FALSE}
chng_fall = get_increase_points(change_healthcare_prepared_fall$cases, change_healthcare_prepared_fall$indicator)
chng_summer = get_increase_points(change_healthcare_prepared_summer$cases, change_healthcare_prepared_summer$indicator)

success_examples_chng_fall = get_success_examples(chng_fall, success_window_max = 14, success_window_min = 3)
success_examples_chng_summer = get_success_examples(chng_summer, success_window_max = 14, success_window_min = 3)

chng_success_intersect = intersect(success_examples_chng_fall, success_examples_chng_summer)
```
#### We can plot some of the counties where rises in the Change Healthcare indicator consistently lead rises in cases. {.tabset .tabset-fade .tabset-pills}
##### Examples from the Summer
```{r echo=FALSE}
plot_example_list(success_examples_chng_summer, chng_summer, "Change Healthcare CLI")
```

##### Examples from the Fall
```{r echo=FALSE}
plot_example_list(success_examples_chng_fall, chng_fall, "Change Healthcare CLI")
```

##### Examples of counties that show successes in both Summer and Fall
```{r, echo=FALSE}
plot_example_intersects(success_examples_chng_summer, success_examples_chng_fall, chng_summer, chng_fall, "Change Healthcare CLI")
```

##### Fall Frequencies
We can also look at the distribution of the frequency of the number of days by which Change Healthcare rises lead case rises in successful counties
```{r echo=FALSE}
plot_distribution_freq(success_examples_chng_fall, chng_fall)
```
##### Summer Frequencies
We can also look at the distribution of the frequency of the number of days by which Change Healthcare rises lead case rises in successful counties
```{r echo=FALSE}
plot_distribution_freq(success_examples_chng_summer, chng_summer)
```

### Indicator Combination
```{r, results='hide', echo=FALSE}
indicator_comb_prepared_fall = get_and_parse_signals("2020-09-01", "2020-11-30", "indicator-combination", "nmf_day_doc_fbc_fbs_ght", 2000, 80)
indicator_comb_prepared_summer = get_and_parse_signals("2020-06-01", "2020-08-31", "indicator-combination", "nmf_day_doc_fbc_fbs_ght", 2000, 80)
```
```{r results="hide", echo=FALSE}
comb_fall = get_increase_points(indicator_comb_prepared_fall$cases, indicator_comb_prepared_fall$indicator)
comb_summer = get_increase_points(indicator_comb_prepared_summer$cases, indicator_comb_prepared_summer$indicator)

success_examples_comb_fall = get_success_examples(comb_fall, success_window_max = 14, success_window_min = 3)
success_examples_comb_summer = get_success_examples(comb_summer, success_window_max = 14, success_window_min = 3)

comb_success_intersect = intersect(success_examples_comb_fall, success_examples_comb_summer)
```

#### We can plot some of the counties where rises in the indicator combination consistently lead rises in cases. {.tabset .tabset-fade .tabset-pills}

##### Examples from the Summer
```{r echo=FALSE}
plot_example_list(success_examples_comb_summer, comb_summer, "Indicator Combination CLI")
```

##### Examples from the Fall
```{r echo=FALSE}
plot_example_list(success_examples_comb_fall, comb_fall, "Indicator Combination CLI")
```

##### Examples of counties that show successes in both Summer and Fall
```{r, echo=FALSE}
plot_example_intersects(success_examples_comb_summer, success_examples_comb_fall, comb_summer, comb_fall, "Indicator Combination CLI")
```
##### Fall Frequencies
We can also look at the distribution of the frequency of the number of days by which Indicator Combination rises lead case rises in successful counties
```{r echo=FALSE}
plot_distribution_freq(success_examples_comb_fall, comb_fall)
```
##### Summer Frequencies
We can also look at the distribution of the frequency of the number of days by which Change Healthcare rises lead case rises in successful counties
```{r echo=FALSE}
plot_distribution_freq(success_examples_comb_summer, comb_summer)
```

##
Note that the counties shown and counted as "successful" here met the following criteria:
All indicator rise points were followed by a case rise point within 3 to 14 days (and all case rise points were preceded by an indicator rise point within the same time period). This means that the displayed counties almost always have only one rise point per signal and case (the more rise points the harder it is to meet the criteria).

## Performance

Recall and precision.

## Conclusions and Limitations

```{r echo=FALSE}
# HELPER FUNCTIONS
plot_example_list = function(success_example_list, signal_data, indicator) {
  plot_list = vector("list", length(success_example_list) )
  for (i in 1:length(success_example_list)) {
    plot_list[[i]] = plot_signals(signal_data, success_example_list[[i]], smooth_and_show_increase_point=TRUE, indicator)
  }
  layout <- rbind(c(1,2),
                      c(1,2),
                      c(1,2),
                      c(1,2))
  
  marrangeGrob(grobs = plot_list, layout_matrix=layout)
}

plot_example_intersects = function(success_example_list1, success_example_list2, signal_data1, signal_data2, indicator) {
  drs_success_intersect = intersect(success_example_list1, success_example_list2)
  plot_list = vector("list", length(drs_success_intersect)*2)
  i = 1
  j = 1
  while (i <= length(drs_success_intersect)*2 && j <= length(drs_success_intersect)) {
    plot_list[[i]] = plot_signals(signal_data1, drs_success_intersect[[j]], smooth_and_show_increase_point=TRUE, indicator)
    plot_list[[i+1]] = plot_signals(signal_data2, drs_success_intersect[[j]], smooth_and_show_increase_point=TRUE, indicator)
    i = i+2
    j = j+1
  
  }
  layout <- rbind(c(1,2),
                      c(1,2),
                      c(1,2),
                      c(1,2))
  marrangeGrob(grobs = plot_list, layout_matrix=layout)
}



get_leading_indicator_day_distribution<-function(success_examples, final_cases_indicator_list)
{
  county_names=unlist(lapply(final_cases_indicator_list, function(x) x$geo_value[1]))
  success_examples_data = final_cases_indicator_list[which(county_names %in% unlist(success_examples))]
  names(success_examples_data)<-unlist(lapply(success_examples_data, function(x) x$geo_value[1]))
  # print(names(success_examples_data))
  return(lapply(success_examples_data, function(x){
    as.integer(x$time_value[which(x$case_rise_point==1)]-x$time_value[which(x$indicator_rise_point==1)])
  }))
}

plot_distribution_freq = function(examples, signal_data) {
  aheads = get_leading_indicator_day_distribution(examples, signal_data)
  distribution = data.frame(leadingness=integer(), freq=integer())
  for (i in 1:length(aheads)) {
    for (j in 1:length(aheads[[i]])) {
      if (aheads[[i]][[j]] %in% distribution$leadingness) {
        distribution$freq[distribution$leadingness == aheads[[i]][[j]]] <- distribution$freq[distribution$leadingness == aheads[[i]][[j]]] + 1
      } else {
        distribution[nrow(distribution) + 1,] = c(aheads[[i]][[j]], 1)
      }
    }
  }
  ggplot(distribution, aes(leadingness, freq)) + 
    geom_bar(aes(fill =leadingness), stat = 'identity') +
    scale_x_continuous(breaks = c(2,3,4,5,6,7,8,9,10,11,12,13,14,15))
}

```
